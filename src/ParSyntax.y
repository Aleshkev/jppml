-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParSyntax
  ( happyError
  , myLexer
  , pListDec
  , pTyp
  , pExp
  ) where

import Prelude

import qualified AbsSyntax
import LexSyntax

}

%name pListDec_internal ListDec
%name pTyp_internal Typ
%name pExp_internal Exp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='        { PT _ (TS _ 1)    }
  '&&'        { PT _ (TS _ 2)    }
  '('         { PT _ (TS _ 3)    }
  ')'         { PT _ (TS _ 4)    }
  '*'         { PT _ (TS _ 5)    }
  '+'         { PT _ (TS _ 6)    }
  ','         { PT _ (TS _ 7)    }
  '-'         { PT _ (TS _ 8)    }
  '->'        { PT _ (TS _ 9)    }
  '/'         { PT _ (TS _ 10)   }
  '::'        { PT _ (TS _ 11)   }
  '<'         { PT _ (TS _ 12)   }
  '<='        { PT _ (TS _ 13)   }
  '='         { PT _ (TS _ 14)   }
  '=='        { PT _ (TS _ 15)   }
  '>'         { PT _ (TS _ 16)   }
  '>='        { PT _ (TS _ 17)   }
  '@'         { PT _ (TS _ 18)   }
  '['         { PT _ (TS _ 19)   }
  ']'         { PT _ (TS _ 20)   }
  '^'         { PT _ (TS _ 21)   }
  '_'         { PT _ (TS _ 22)   }
  'and'       { PT _ (TS _ 23)   }
  'case'      { PT _ (TS _ 24)   }
  'else'      { PT _ (TS _ 25)   }
  'exception' { PT _ (TS _ 26)   }
  'fn'        { PT _ (TS _ 27)   }
  'if'        { PT _ (TS _ 28)   }
  'in'        { PT _ (TS _ 29)   }
  'let'       { PT _ (TS _ 30)   }
  'of'        { PT _ (TS _ 31)   }
  'open'      { PT _ (TS _ 32)   }
  'then'      { PT _ (TS _ 33)   }
  'type'      { PT _ (TS _ 34)   }
  '|'         { PT _ (TS _ 35)   }
  '||'        { PT _ (TS _ 36)   }
  L_integ     { PT _ (TI _)      }
  L_quoted    { PT _ (TL _)      }
  L_Id        { PT _ (T_Id _)    }
  L_IdCap     { PT _ (T_IdCap _) }
  L_IdVar     { PT _ (T_IdVar _) }

%%

Integer :: { (AbsSyntax.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (AbsSyntax.BNFC'Position, String) }
String   : L_quoted { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

Id :: { (AbsSyntax.BNFC'Position, AbsSyntax.Id) }
Id  : L_Id { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.Id (tokenText $1)) }

IdCap :: { (AbsSyntax.BNFC'Position, AbsSyntax.IdCap) }
IdCap  : L_IdCap { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.IdCap (tokenText $1)) }

IdVar :: { (AbsSyntax.BNFC'Position, AbsSyntax.IdVar) }
IdVar  : L_IdVar { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.IdVar (tokenText $1)) }

Con :: { (AbsSyntax.BNFC'Position, AbsSyntax.Con) }
Con
  : Integer { (fst $1, AbsSyntax.CInt (fst $1) (snd $1)) }
  | String { (fst $1, AbsSyntax.CString (fst $1) (snd $1)) }
  | '(' ')' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.CUnit (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }

Exp11 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp11
  : Con { (fst $1, AbsSyntax.ECon (fst $1) (snd $1)) }
  | IdCap { (fst $1, AbsSyntax.EObjCon (fst $1) (snd $1)) }
  | Id { (fst $1, AbsSyntax.EId (fst $1) (snd $1)) }
  | '(' Exp ',' ListExp ')' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ETup (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '[' ListExp ']' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ELst (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Exp ')' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListExp :: { (AbsSyntax.BNFC'Position, [AbsSyntax.Exp]) }
ListExp
  : {- empty -} { (AbsSyntax.BNFC'NoPosition, []) }
  | Exp { (fst $1, (:[]) (snd $1)) }
  | Exp ',' ListExp { (fst $1, (:) (snd $1) (snd $3)) }

Exp10 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp10
  : Exp10 Exp11 { (fst $1, AbsSyntax.EApp (fst $1) (snd $1) (snd $2)) }
  | Exp11 { (fst $1, (snd $1)) }

Exp9 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp9
  : '-' Exp10 { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ENeg (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Exp10 { (fst $1, (snd $1)) }

Exp8 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp8
  : Exp8 '*' Exp9 { (fst $1, AbsSyntax.EMul (fst $1) (snd $1) (snd $3)) }
  | Exp8 '/' Exp9 { (fst $1, AbsSyntax.EDiv (fst $1) (snd $1) (snd $3)) }
  | Exp9 { (fst $1, (snd $1)) }

Exp7 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp7
  : Exp7 '+' Exp8 { (fst $1, AbsSyntax.EAdd (fst $1) (snd $1) (snd $3)) }
  | Exp7 '-' Exp8 { (fst $1, AbsSyntax.ESub (fst $1) (snd $1) (snd $3)) }
  | Exp8 { (fst $1, (snd $1)) }

Exp6 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp6
  : Exp7 '::' Exp6 { (fst $1, AbsSyntax.ECons (fst $1) (snd $1) (snd $3)) }
  | Exp7 { (fst $1, (snd $1)) }

Exp5 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp5
  : Exp6 '@' Exp5 { (fst $1, AbsSyntax.EAppend (fst $1) (snd $1) (snd $3)) }
  | Exp6 '^' Exp5 { (fst $1, AbsSyntax.ECat (fst $1) (snd $1) (snd $3)) }
  | Exp6 { (fst $1, (snd $1)) }

Exp4 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp4
  : Exp5 ERelOp Exp5 { (fst $1, AbsSyntax.ERel (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Exp5 { (fst $1, (snd $1)) }

ERelOp :: { (AbsSyntax.BNFC'Position, AbsSyntax.ERelOp) }
ERelOp
  : '==' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.EREq (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ERNe (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | '<' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ERLt (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ERLe (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ERGt (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ERGe (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }

Exp3 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp3
  : Exp3 '&&' Exp4 { (fst $1, AbsSyntax.EAnd (fst $1) (snd $1) (snd $3)) }
  | Exp4 { (fst $1, (snd $1)) }

Exp2 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp2
  : Exp2 '||' Exp3 { (fst $1, AbsSyntax.EOr (fst $1) (snd $1) (snd $3)) }
  | Exp3 { (fst $1, (snd $1)) }

Exp1 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp1
  : 'if' Exp 'then' Exp 'else' Exp1 { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.EIf (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | Exp2 { (fst $1, (snd $1)) }

Exp :: { (AbsSyntax.BNFC'Position, AbsSyntax.Exp) }
Exp
  : 'let' ListLetBind 'in' Exp { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ELet (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'case' Exp 'of' ListECaseBind { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.ECase (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'case' Exp 'of' '|' ListECaseBind { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.eCaseAlt (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }
  | 'fn' ListId '->' Exp { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.EFn (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Exp1 { (fst $1, (snd $1)) }

ECaseBind :: { (AbsSyntax.BNFC'Position, AbsSyntax.ECaseBind) }
ECaseBind
  : Pat '->' Exp { (fst $1, AbsSyntax.ECBJust (fst $1) (snd $1) (snd $3)) }

ListECaseBind :: { (AbsSyntax.BNFC'Position, [AbsSyntax.ECaseBind]) }
ListECaseBind
  : ECaseBind { (fst $1, (:[]) (snd $1)) }
  | ECaseBind '|' ListECaseBind { (fst $1, (:) (snd $1) (snd $3)) }

ListId :: { (AbsSyntax.BNFC'Position, [AbsSyntax.Id]) }
ListId
  : Id { (fst $1, (:[]) (snd $1)) }
  | Id ListId { (fst $1, (:) (snd $1) (snd $2)) }

Pat3 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Pat) }
Pat3
  : Con { (fst $1, AbsSyntax.PCon (fst $1) (snd $1)) }
  | Id { (fst $1, AbsSyntax.PId (fst $1) (snd $1)) }
  | '_' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.PWild (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | '(' Pat ',' ListPat ')' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.PTup (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '[' ListPat ']' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.PLst (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | IdCap { (fst $1, AbsSyntax.PObjCon (fst $1) (snd $1)) }
  | '(' Pat ')' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListPat :: { (AbsSyntax.BNFC'Position, [AbsSyntax.Pat]) }
ListPat
  : {- empty -} { (AbsSyntax.BNFC'NoPosition, []) }
  | Pat { (fst $1, (:[]) (snd $1)) }
  | Pat ',' ListPat { (fst $1, (:) (snd $1) (snd $3)) }

Pat1 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Pat) }
Pat1
  : IdCap Pat2 { (fst $1, AbsSyntax.PObj (fst $1) (snd $1) (snd $2)) }
  | Pat2 { (fst $1, (snd $1)) }

Pat :: { (AbsSyntax.BNFC'Position, AbsSyntax.Pat) }
Pat
  : Pat1 '::' Pat { (fst $1, AbsSyntax.PCons (fst $1) (snd $1) (snd $3)) }
  | Pat1 { (fst $1, (snd $1)) }

Pat2 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Pat) }
Pat2 : Pat3 { (fst $1, (snd $1)) }

Typ3 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Typ) }
Typ3
  : IdVar { (fst $1, AbsSyntax.TIdVar (fst $1) (snd $1)) }
  | TypLst Id { (fst $1, AbsSyntax.TId (fst $1) (snd $1) (snd $2)) }
  | '(' Typ ')' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), (snd $2)) }

TypLst :: { (AbsSyntax.BNFC'Position, AbsSyntax.TypLst) }
TypLst
  : {- empty -} { (AbsSyntax.BNFC'NoPosition, AbsSyntax.TLEmpty AbsSyntax.BNFC'NoPosition) }
  | Typ3 { (fst $1, AbsSyntax.TLOne (fst $1) (snd $1)) }
  | '(' Typ ',' ListTyp ')' { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.TLMany (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListTyp :: { (AbsSyntax.BNFC'Position, [AbsSyntax.Typ]) }
ListTyp
  : Typ { (fst $1, (:[]) (snd $1)) }
  | Typ ',' ListTyp { (fst $1, (:) (snd $1) (snd $3)) }

Typ1 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Typ) }
Typ1
  : Typ2 '*' ListTTupElem { (fst $1, AbsSyntax.TTup (fst $1) (snd $1) (snd $3)) }
  | Typ2 { (fst $1, (snd $1)) }

TTupElem :: { (AbsSyntax.BNFC'Position, AbsSyntax.TTupElem) }
TTupElem : Typ2 { (fst $1, AbsSyntax.TTupJust (fst $1) (snd $1)) }

ListTTupElem :: { (AbsSyntax.BNFC'Position, [AbsSyntax.TTupElem]) }
ListTTupElem
  : TTupElem { (fst $1, (:[]) (snd $1)) }
  | TTupElem '*' ListTTupElem { (fst $1, (:) (snd $1) (snd $3)) }

Typ :: { (AbsSyntax.BNFC'Position, AbsSyntax.Typ) }
Typ
  : Typ1 '->' Typ { (fst $1, AbsSyntax.TFn (fst $1) (snd $1) (snd $3)) }
  | Typ1 { (fst $1, (snd $1)) }

Typ2 :: { (AbsSyntax.BNFC'Position, AbsSyntax.Typ) }
Typ2 : Typ3 { (fst $1, (snd $1)) }

Dec :: { (AbsSyntax.BNFC'Position, AbsSyntax.Dec) }
Dec
  : 'let' ListLetBind { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.DLet (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'type' ListTypBind { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.DType (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'exception' ListExnBind { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.DExn (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'open' ListIdCap { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.DOpen (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListIdCap :: { (AbsSyntax.BNFC'Position, [AbsSyntax.IdCap]) }
ListIdCap
  : IdCap { (fst $1, (:[]) (snd $1)) }
  | IdCap 'and' ListIdCap { (fst $1, (:) (snd $1) (snd $3)) }

ListDec :: { (AbsSyntax.BNFC'Position, [AbsSyntax.Dec]) }
ListDec
  : {- empty -} { (AbsSyntax.BNFC'NoPosition, []) }
  | Dec ListDec { (fst $1, (:) (snd $1) (snd $2)) }

LetBind :: { (AbsSyntax.BNFC'Position, AbsSyntax.LetBind) }
LetBind
  : Id '=' Exp { (fst $1, AbsSyntax.LBJust (fst $1) (snd $1) (snd $3)) }
  | '_' '=' Exp { (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1), AbsSyntax.LBAnon (uncurry AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }

ListLetBind :: { (AbsSyntax.BNFC'Position, [AbsSyntax.LetBind]) }
ListLetBind
  : LetBind { (fst $1, (:[]) (snd $1)) }
  | LetBind 'and' ListLetBind { (fst $1, (:) (snd $1) (snd $3)) }

TypBind :: { (AbsSyntax.BNFC'Position, AbsSyntax.TypBind) }
TypBind
  : TypLst Id '=' ListDTag { (fst $1, AbsSyntax.TBJust (fst $1) (snd $1) (snd $2) (snd $4)) }
  | TypLst Id '=' '|' ListDTag { (fst $1, AbsSyntax.tBJust (fst $1) (snd $1) (snd $2) (snd $5)) }

ListTypBind :: { (AbsSyntax.BNFC'Position, [AbsSyntax.TypBind]) }
ListTypBind
  : TypBind { (fst $1, (:[]) (snd $1)) }
  | TypBind 'and' ListTypBind { (fst $1, (:) (snd $1) (snd $3)) }

DTag :: { (AbsSyntax.BNFC'Position, AbsSyntax.DTag) }
DTag
  : IdCap { (fst $1, AbsSyntax.DTCon (fst $1) (snd $1)) }
  | IdCap 'of' Typ { (fst $1, AbsSyntax.DTArg (fst $1) (snd $1) (snd $3)) }

ListDTag :: { (AbsSyntax.BNFC'Position, [AbsSyntax.DTag]) }
ListDTag
  : DTag { (fst $1, (:[]) (snd $1)) }
  | DTag '|' ListDTag { (fst $1, (:) (snd $1) (snd $3)) }

ExnBind :: { (AbsSyntax.BNFC'Position, AbsSyntax.ExnBind) }
ExnBind
  : IdCap { (fst $1, AbsSyntax.EBCon (fst $1) (snd $1)) }
  | IdCap 'of' Typ { (fst $1, AbsSyntax.EBArg (fst $1) (snd $1) (snd $3)) }

ListExnBind :: { (AbsSyntax.BNFC'Position, [AbsSyntax.ExnBind]) }
ListExnBind
  : ExnBind { (fst $1, (:[]) (snd $1)) }
  | ExnBind 'and' ListExnBind { (fst $1, (:) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pListDec :: [Token] -> Err [AbsSyntax.Dec]
pListDec = fmap snd . pListDec_internal

pTyp :: [Token] -> Err AbsSyntax.Typ
pTyp = fmap snd . pTyp_internal

pExp :: [Token] -> Err AbsSyntax.Exp
pExp = fmap snd . pExp_internal
}

