-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language jppml.

module Jppml.Abs where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

type Con = Con' BNFC'Position
data Con' a = CInt a Integer | CString a String | CUnit a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Exp = Exp' BNFC'Position
data Exp' a
    = ECon a (Con' a)
    | EObjCon a IdCap
    | EId a Id
    | ETup a (Exp' a) [Exp' a]
    | ELst a [Exp' a]
    | EApp a (Exp' a) (Exp' a)
    | ENeg a (Exp' a)
    | EMul a (Exp' a) (Exp' a)
    | EDiv a (Exp' a) (Exp' a)
    | EAdd a (Exp' a) (Exp' a)
    | ESub a (Exp' a) (Exp' a)
    | ECons a (Exp' a) (Exp' a)
    | EAppend a (Exp' a) (Exp' a)
    | ECat a (Exp' a) (Exp' a)
    | ERel a (Exp' a) (ERelOp' a) (Exp' a)
    | EAnd a (Exp' a) (Exp' a)
    | EOr a (Exp' a) (Exp' a)
    | EIf a (Exp' a) (Exp' a) (Exp' a)
    | ELet a [LetBind' a] (Exp' a)
    | ECase a (Exp' a) [ECaseBind' a]
    | EFn a [Id] (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ERelOp = ERelOp' BNFC'Position
data ERelOp' a
    = EREq a | ERNe a | ERLt a | ERLe a | ERGt a | ERGe a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ECaseBind = ECaseBind' BNFC'Position
data ECaseBind' a = ECBJust a (Pat' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Pat = Pat' BNFC'Position
data Pat' a
    = PCon a (Con' a)
    | PId a Id
    | PWild a
    | PTup a (Pat' a) [Pat' a]
    | PLst a [Pat' a]
    | PObjCon a IdCap
    | PObj a IdCap (Pat' a)
    | PCons a (Pat' a) (Pat' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Typ = Typ' BNFC'Position
data Typ' a
    = TIdVar a IdVar
    | TId a (TypLst' a) Id
    | TTup a (Typ' a) [TTupElem' a]
    | TFn a (Typ' a) (Typ' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TypLst = TypLst' BNFC'Position
data TypLst' a
    = TLEmpty a | TLOne a (Typ' a) | TLMany a (Typ' a) [Typ' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TTupElem = TTupElem' BNFC'Position
data TTupElem' a = TTupJust a (Typ' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Dec = Dec' BNFC'Position
data Dec' a
    = DLet a [LetBind' a]
    | DType a [TypBind' a]
    | DExn a [ExnBind' a]
    | DOpen a [IdCap]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type LetBind = LetBind' BNFC'Position
data LetBind' a = LBJust a Id (Exp' a) | LBAnon a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TypBind = TypBind' BNFC'Position
data TypBind' a = TBJust a (TypLst' a) Id [DTag' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type DTag = DTag' BNFC'Position
data DTag' a = DTCon a IdCap | DTArg a IdCap (Typ' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ExnBind = ExnBind' BNFC'Position
data ExnBind' a = EBCon a IdCap | EBArg a IdCap (Typ' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

eCaseAlt :: a -> Exp' a -> [ECaseBind' a] -> Exp' a
eCaseAlt = \ _a a b -> ECase _a a b

tBJust :: a -> TypLst' a -> Id -> [DTag' a] -> TypBind' a
tBJust = \ _a a b c -> TBJust _a a b c

newtype Id = Id String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype IdCap = IdCap String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype IdVar = IdVar String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Con where
  hasPosition = \case
    CInt p _ -> p
    CString p _ -> p
    CUnit p -> p

instance HasPosition Exp where
  hasPosition = \case
    ECon p _ -> p
    EObjCon p _ -> p
    EId p _ -> p
    ETup p _ _ -> p
    ELst p _ -> p
    EApp p _ _ -> p
    ENeg p _ -> p
    EMul p _ _ -> p
    EDiv p _ _ -> p
    EAdd p _ _ -> p
    ESub p _ _ -> p
    ECons p _ _ -> p
    EAppend p _ _ -> p
    ECat p _ _ -> p
    ERel p _ _ _ -> p
    EAnd p _ _ -> p
    EOr p _ _ -> p
    EIf p _ _ _ -> p
    ELet p _ _ -> p
    ECase p _ _ -> p
    EFn p _ _ -> p

instance HasPosition ERelOp where
  hasPosition = \case
    EREq p -> p
    ERNe p -> p
    ERLt p -> p
    ERLe p -> p
    ERGt p -> p
    ERGe p -> p

instance HasPosition ECaseBind where
  hasPosition = \case
    ECBJust p _ _ -> p

instance HasPosition Pat where
  hasPosition = \case
    PCon p _ -> p
    PId p _ -> p
    PWild p -> p
    PTup p _ _ -> p
    PLst p _ -> p
    PObjCon p _ -> p
    PObj p _ _ -> p
    PCons p _ _ -> p

instance HasPosition Typ where
  hasPosition = \case
    TIdVar p _ -> p
    TId p _ _ -> p
    TTup p _ _ -> p
    TFn p _ _ -> p

instance HasPosition TypLst where
  hasPosition = \case
    TLEmpty p -> p
    TLOne p _ -> p
    TLMany p _ _ -> p

instance HasPosition TTupElem where
  hasPosition = \case
    TTupJust p _ -> p

instance HasPosition Dec where
  hasPosition = \case
    DLet p _ -> p
    DType p _ -> p
    DExn p _ -> p
    DOpen p _ -> p

instance HasPosition LetBind where
  hasPosition = \case
    LBJust p _ _ -> p
    LBAnon p _ -> p

instance HasPosition TypBind where
  hasPosition = \case
    TBJust p _ _ _ -> p

instance HasPosition DTag where
  hasPosition = \case
    DTCon p _ -> p
    DTArg p _ _ -> p

instance HasPosition ExnBind where
  hasPosition = \case
    EBCon p _ -> p
    EBArg p _ _ -> p

