-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Jppml.Par
  ( happyError
  , myLexer
  , pListDec
  ) where

import Prelude

import qualified Jppml.Abs
import Jppml.Lex

}

%name pListDec ListDec
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='        { PT _ (TS _ 1)     }
  '&&'        { PT _ (TS _ 2)     }
  '('         { PT _ (TS _ 3)     }
  ')'         { PT _ (TS _ 4)     }
  '*'         { PT _ (TS _ 5)     }
  '+'         { PT _ (TS _ 6)     }
  ','         { PT _ (TS _ 7)     }
  '-'         { PT _ (TS _ 8)     }
  '->'        { PT _ (TS _ 9)     }
  '/'         { PT _ (TS _ 10)    }
  '::'        { PT _ (TS _ 11)    }
  '<'         { PT _ (TS _ 12)    }
  '<='        { PT _ (TS _ 13)    }
  '='         { PT _ (TS _ 14)    }
  '=='        { PT _ (TS _ 15)    }
  '>'         { PT _ (TS _ 16)    }
  '>='        { PT _ (TS _ 17)    }
  '@'         { PT _ (TS _ 18)    }
  '['         { PT _ (TS _ 19)    }
  ']'         { PT _ (TS _ 20)    }
  '^'         { PT _ (TS _ 21)    }
  '_'         { PT _ (TS _ 22)    }
  'and'       { PT _ (TS _ 23)    }
  'case'      { PT _ (TS _ 24)    }
  'else'      { PT _ (TS _ 25)    }
  'exception' { PT _ (TS _ 26)    }
  'fn'        { PT _ (TS _ 27)    }
  'if'        { PT _ (TS _ 28)    }
  'in'        { PT _ (TS _ 29)    }
  'let'       { PT _ (TS _ 30)    }
  'of'        { PT _ (TS _ 31)    }
  'open'      { PT _ (TS _ 32)    }
  'then'      { PT _ (TS _ 33)    }
  'type'      { PT _ (TS _ 34)    }
  '|'         { PT _ (TS _ 35)    }
  '||'        { PT _ (TS _ 36)    }
  L_integ     { PT _ (TI $$)      }
  L_quoted    { PT _ (TL $$)      }
  L_Id        { PT _ (T_Id $$)    }
  L_IdCap     { PT _ (T_IdCap $$) }
  L_IdVar     { PT _ (T_IdVar $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Id :: { Jppml.Abs.Id }
Id  : L_Id { Jppml.Abs.Id $1 }

IdCap :: { Jppml.Abs.IdCap }
IdCap  : L_IdCap { Jppml.Abs.IdCap $1 }

IdVar :: { Jppml.Abs.IdVar }
IdVar  : L_IdVar { Jppml.Abs.IdVar $1 }

Con :: { Jppml.Abs.Con }
Con
  : Integer { Jppml.Abs.CInt $1 }
  | String { Jppml.Abs.CString $1 }
  | '(' ')' { Jppml.Abs.CUnit }

Exp11 :: { Jppml.Abs.Exp }
Exp11
  : Con { Jppml.Abs.ECon $1 }
  | IdCap { Jppml.Abs.EObjCon $1 }
  | Id { Jppml.Abs.EId $1 }
  | '(' Exp ',' ListExp ')' { Jppml.Abs.ETup $2 $4 }
  | '[' ListExp ']' { Jppml.Abs.ELst $2 }
  | '(' Exp ')' { $2 }

ListExp :: { [Jppml.Abs.Exp] }
ListExp
  : {- empty -} { [] }
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }

Exp10 :: { Jppml.Abs.Exp }
Exp10 : Exp10 Exp11 { Jppml.Abs.EApp $1 $2 } | Exp11 { $1 }

Exp9 :: { Jppml.Abs.Exp }
Exp9 : '-' Exp10 { Jppml.Abs.ENeg $2 } | Exp10 { $1 }

Exp8 :: { Jppml.Abs.Exp }
Exp8
  : Exp8 '*' Exp9 { Jppml.Abs.EMul $1 $3 }
  | Exp8 '/' Exp9 { Jppml.Abs.EDiv $1 $3 }
  | Exp9 { $1 }

Exp7 :: { Jppml.Abs.Exp }
Exp7
  : Exp7 '+' Exp8 { Jppml.Abs.EAdd $1 $3 }
  | Exp7 '-' Exp8 { Jppml.Abs.ESub $1 $3 }
  | Exp8 { $1 }

Exp6 :: { Jppml.Abs.Exp }
Exp6 : Exp7 '::' Exp6 { Jppml.Abs.ECons $1 $3 } | Exp7 { $1 }

Exp5 :: { Jppml.Abs.Exp }
Exp5
  : Exp6 '@' Exp5 { Jppml.Abs.EAppend $1 $3 }
  | Exp6 '^' Exp5 { Jppml.Abs.ECat $1 $3 }
  | Exp6 { $1 }

Exp4 :: { Jppml.Abs.Exp }
Exp4 : Exp5 ERelOp Exp5 { Jppml.Abs.ERel $1 $2 $3 } | Exp5 { $1 }

ERelOp :: { Jppml.Abs.ERelOp }
ERelOp
  : '==' { Jppml.Abs.EREq }
  | '!=' { Jppml.Abs.ERNe }
  | '<' { Jppml.Abs.ERLt }
  | '<=' { Jppml.Abs.ERLe }
  | '>' { Jppml.Abs.ERGt }
  | '>=' { Jppml.Abs.ERGe }

Exp3 :: { Jppml.Abs.Exp }
Exp3 : Exp3 '&&' Exp4 { Jppml.Abs.EAnd $1 $3 } | Exp4 { $1 }

Exp2 :: { Jppml.Abs.Exp }
Exp2 : Exp2 '||' Exp3 { Jppml.Abs.EOr $1 $3 } | Exp3 { $1 }

Exp1 :: { Jppml.Abs.Exp }
Exp1
  : 'if' Exp 'then' Exp 'else' Exp1 { Jppml.Abs.EIf $2 $4 $6 }
  | Exp2 { $1 }

Exp :: { Jppml.Abs.Exp }
Exp
  : 'let' ListLetBind 'in' Exp { Jppml.Abs.ELet $2 $4 }
  | 'case' Exp 'of' ListECaseBind { Jppml.Abs.ECase $2 $4 }
  | 'case' Exp 'of' '|' ListECaseBind { Jppml.Abs.eCaseAlt $2 $5 }
  | 'fn' ListId '->' Exp { Jppml.Abs.EFn $2 $4 }
  | Exp1 { $1 }

ECaseBind :: { Jppml.Abs.ECaseBind }
ECaseBind : Pat '->' Exp { Jppml.Abs.ECBJust $1 $3 }

ListECaseBind :: { [Jppml.Abs.ECaseBind] }
ListECaseBind
  : ECaseBind { (:[]) $1 }
  | ECaseBind '|' ListECaseBind { (:) $1 $3 }

ListId :: { [Jppml.Abs.Id] }
ListId : Id { (:[]) $1 } | Id ListId { (:) $1 $2 }

Pat3 :: { Jppml.Abs.Pat }
Pat3
  : Con { Jppml.Abs.PCon $1 }
  | Id { Jppml.Abs.PId $1 }
  | '_' { Jppml.Abs.PWild }
  | '(' Pat ',' ListPat ')' { Jppml.Abs.PTup $2 $4 }
  | '[' ListPat ']' { Jppml.Abs.PLst $2 }
  | IdCap { Jppml.Abs.PObjCon $1 }
  | '(' Pat ')' { $2 }

ListPat :: { [Jppml.Abs.Pat] }
ListPat
  : {- empty -} { [] }
  | Pat { (:[]) $1 }
  | Pat ',' ListPat { (:) $1 $3 }

Pat1 :: { Jppml.Abs.Pat }
Pat1 : IdCap Pat2 { Jppml.Abs.PObj $1 $2 } | Pat2 { $1 }

Pat :: { Jppml.Abs.Pat }
Pat : Pat1 '::' Pat { Jppml.Abs.PCons $1 $3 } | Pat1 { $1 }

Pat2 :: { Jppml.Abs.Pat }
Pat2 : Pat3 { $1 }

Typ3 :: { Jppml.Abs.Typ }
Typ3
  : IdVar { Jppml.Abs.TIdVar $1 }
  | TypLst Id { Jppml.Abs.TId $1 $2 }
  | '(' Typ ')' { $2 }

TypLst :: { Jppml.Abs.TypLst }
TypLst
  : {- empty -} { Jppml.Abs.TLEmpty }
  | Typ3 { Jppml.Abs.TLOne $1 }
  | '(' Typ ',' ListTyp ')' { Jppml.Abs.TLMany $2 $4 }

ListTyp :: { [Jppml.Abs.Typ] }
ListTyp : Typ { (:[]) $1 } | Typ ',' ListTyp { (:) $1 $3 }

Typ1 :: { Jppml.Abs.Typ }
Typ1 : Typ2 '*' ListTTupElem { Jppml.Abs.TTup $1 $3 } | Typ2 { $1 }

TTupElem :: { Jppml.Abs.TTupElem }
TTupElem : Typ2 { Jppml.Abs.TTupJust $1 }

ListTTupElem :: { [Jppml.Abs.TTupElem] }
ListTTupElem
  : TTupElem { (:[]) $1 } | TTupElem '*' ListTTupElem { (:) $1 $3 }

Typ :: { Jppml.Abs.Typ }
Typ : Typ1 '->' Typ { Jppml.Abs.TFn $1 $3 } | Typ1 { $1 }

Typ2 :: { Jppml.Abs.Typ }
Typ2 : Typ3 { $1 }

Dec :: { Jppml.Abs.Dec }
Dec
  : 'let' ListLetBind { Jppml.Abs.DLet $2 }
  | 'type' ListTypBind { Jppml.Abs.DType $2 }
  | 'exception' ListExnBind { Jppml.Abs.DExn $2 }
  | 'open' ListIdCap { Jppml.Abs.DOpen $2 }

ListIdCap :: { [Jppml.Abs.IdCap] }
ListIdCap
  : IdCap { (:[]) $1 } | IdCap 'and' ListIdCap { (:) $1 $3 }

ListDec :: { [Jppml.Abs.Dec] }
ListDec : {- empty -} { [] } | Dec ListDec { (:) $1 $2 }

LetBind :: { Jppml.Abs.LetBind }
LetBind
  : Id '=' Exp { Jppml.Abs.LBJust $1 $3 }
  | '_' '=' Exp { Jppml.Abs.LBAnon $3 }

ListLetBind :: { [Jppml.Abs.LetBind] }
ListLetBind
  : LetBind { (:[]) $1 } | LetBind 'and' ListLetBind { (:) $1 $3 }

TypBind :: { Jppml.Abs.TypBind }
TypBind
  : TypLst Id '=' ListDTag { Jppml.Abs.TBJust $1 $2 $4 }
  | TypLst Id '=' '|' ListDTag { Jppml.Abs.tBJust $1 $2 $5 }

ListTypBind :: { [Jppml.Abs.TypBind] }
ListTypBind
  : TypBind { (:[]) $1 } | TypBind 'and' ListTypBind { (:) $1 $3 }

DTag :: { Jppml.Abs.DTag }
DTag
  : IdCap { Jppml.Abs.DTCon $1 }
  | IdCap 'of' Typ { Jppml.Abs.DTArg $1 $3 }

ListDTag :: { [Jppml.Abs.DTag] }
ListDTag : DTag { (:[]) $1 } | DTag '|' ListDTag { (:) $1 $3 }

ExnBind :: { Jppml.Abs.ExnBind }
ExnBind
  : IdCap { Jppml.Abs.EBCon $1 }
  | IdCap 'of' Typ { Jppml.Abs.EBArg $1 $3 }

ListExnBind :: { [Jppml.Abs.ExnBind] }
ListExnBind
  : ExnBind { (:[]) $1 } | ExnBind 'and' ListExnBind { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

