-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Jppml.Par
  ( happyError
  , myLexer
  , pListDec
  ) where

import Prelude

import qualified Jppml.Abs
import Jppml.Lex

}

%name pListDec_internal ListDec
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='        { PT _ (TS _ 1)    }
  '&&'        { PT _ (TS _ 2)    }
  '('         { PT _ (TS _ 3)    }
  ')'         { PT _ (TS _ 4)    }
  '*'         { PT _ (TS _ 5)    }
  '+'         { PT _ (TS _ 6)    }
  ','         { PT _ (TS _ 7)    }
  '-'         { PT _ (TS _ 8)    }
  '->'        { PT _ (TS _ 9)    }
  '/'         { PT _ (TS _ 10)   }
  '::'        { PT _ (TS _ 11)   }
  '<'         { PT _ (TS _ 12)   }
  '<='        { PT _ (TS _ 13)   }
  '='         { PT _ (TS _ 14)   }
  '=='        { PT _ (TS _ 15)   }
  '>'         { PT _ (TS _ 16)   }
  '>='        { PT _ (TS _ 17)   }
  '@'         { PT _ (TS _ 18)   }
  '['         { PT _ (TS _ 19)   }
  ']'         { PT _ (TS _ 20)   }
  '^'         { PT _ (TS _ 21)   }
  '_'         { PT _ (TS _ 22)   }
  'and'       { PT _ (TS _ 23)   }
  'case'      { PT _ (TS _ 24)   }
  'else'      { PT _ (TS _ 25)   }
  'exception' { PT _ (TS _ 26)   }
  'fn'        { PT _ (TS _ 27)   }
  'if'        { PT _ (TS _ 28)   }
  'in'        { PT _ (TS _ 29)   }
  'let'       { PT _ (TS _ 30)   }
  'of'        { PT _ (TS _ 31)   }
  'open'      { PT _ (TS _ 32)   }
  'then'      { PT _ (TS _ 33)   }
  'type'      { PT _ (TS _ 34)   }
  '|'         { PT _ (TS _ 35)   }
  '||'        { PT _ (TS _ 36)   }
  L_integ     { PT _ (TI _)      }
  L_quoted    { PT _ (TL _)      }
  L_Id        { PT _ (T_Id _)    }
  L_IdCap     { PT _ (T_IdCap _) }
  L_IdVar     { PT _ (T_IdVar _) }

%%

Integer :: { (Jppml.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (Jppml.Abs.BNFC'Position, String) }
String   : L_quoted { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

Id :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Id) }
Id  : L_Id { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.Id (tokenText $1)) }

IdCap :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.IdCap) }
IdCap  : L_IdCap { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.IdCap (tokenText $1)) }

IdVar :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.IdVar) }
IdVar  : L_IdVar { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.IdVar (tokenText $1)) }

Con :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Con) }
Con
  : Integer { (fst $1, Jppml.Abs.CInt (fst $1) (snd $1)) }
  | String { (fst $1, Jppml.Abs.CString (fst $1) (snd $1)) }
  | '(' ')' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.CUnit (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }

Exp11 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp11
  : Con { (fst $1, Jppml.Abs.ECon (fst $1) (snd $1)) }
  | IdCap { (fst $1, Jppml.Abs.EObjCon (fst $1) (snd $1)) }
  | Id { (fst $1, Jppml.Abs.EId (fst $1) (snd $1)) }
  | '(' Exp ',' ListExp ')' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ETup (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '[' ListExp ']' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ELst (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Exp ')' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListExp :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.Exp]) }
ListExp
  : {- empty -} { (Jppml.Abs.BNFC'NoPosition, []) }
  | Exp { (fst $1, (:[]) (snd $1)) }
  | Exp ',' ListExp { (fst $1, (:) (snd $1) (snd $3)) }

Exp10 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp10
  : Exp10 Exp11 { (fst $1, Jppml.Abs.EApp (fst $1) (snd $1) (snd $2)) }
  | Exp11 { (fst $1, (snd $1)) }

Exp9 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp9
  : '-' Exp10 { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ENeg (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Exp10 { (fst $1, (snd $1)) }

Exp8 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp8
  : Exp8 '*' Exp9 { (fst $1, Jppml.Abs.EMul (fst $1) (snd $1) (snd $3)) }
  | Exp8 '/' Exp9 { (fst $1, Jppml.Abs.EDiv (fst $1) (snd $1) (snd $3)) }
  | Exp9 { (fst $1, (snd $1)) }

Exp7 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp7
  : Exp7 '+' Exp8 { (fst $1, Jppml.Abs.EAdd (fst $1) (snd $1) (snd $3)) }
  | Exp7 '-' Exp8 { (fst $1, Jppml.Abs.ESub (fst $1) (snd $1) (snd $3)) }
  | Exp8 { (fst $1, (snd $1)) }

Exp6 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp6
  : Exp7 '::' Exp6 { (fst $1, Jppml.Abs.ECons (fst $1) (snd $1) (snd $3)) }
  | Exp7 { (fst $1, (snd $1)) }

Exp5 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp5
  : Exp6 '@' Exp5 { (fst $1, Jppml.Abs.EAppend (fst $1) (snd $1) (snd $3)) }
  | Exp6 '^' Exp5 { (fst $1, Jppml.Abs.ECat (fst $1) (snd $1) (snd $3)) }
  | Exp6 { (fst $1, (snd $1)) }

Exp4 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp4
  : Exp5 ERelOp Exp5 { (fst $1, Jppml.Abs.ERel (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Exp5 { (fst $1, (snd $1)) }

ERelOp :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.ERelOp) }
ERelOp
  : '==' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.EREq (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ERNe (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }
  | '<' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ERLt (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ERLe (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ERGt (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ERGe (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }

Exp3 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp3
  : Exp3 '&&' Exp4 { (fst $1, Jppml.Abs.EAnd (fst $1) (snd $1) (snd $3)) }
  | Exp4 { (fst $1, (snd $1)) }

Exp2 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp2
  : Exp2 '||' Exp3 { (fst $1, Jppml.Abs.EOr (fst $1) (snd $1) (snd $3)) }
  | Exp3 { (fst $1, (snd $1)) }

Exp1 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp1
  : 'if' Exp 'then' Exp 'else' Exp1 { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.EIf (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | Exp2 { (fst $1, (snd $1)) }

Exp :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Exp) }
Exp
  : 'let' ListLetBind 'in' Exp { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ELet (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'case' Exp 'of' ListECaseBind { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.ECase (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'case' Exp 'of' '|' ListECaseBind { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.eCaseAlt (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }
  | 'fn' ListId '->' Exp { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.EFn (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Exp1 { (fst $1, (snd $1)) }

ECaseBind :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.ECaseBind) }
ECaseBind
  : Pat '->' Exp { (fst $1, Jppml.Abs.ECBJust (fst $1) (snd $1) (snd $3)) }

ListECaseBind :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.ECaseBind]) }
ListECaseBind
  : ECaseBind { (fst $1, (:[]) (snd $1)) }
  | ECaseBind '|' ListECaseBind { (fst $1, (:) (snd $1) (snd $3)) }

ListId :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.Id]) }
ListId
  : Id { (fst $1, (:[]) (snd $1)) }
  | Id ListId { (fst $1, (:) (snd $1) (snd $2)) }

Pat3 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Pat) }
Pat3
  : Con { (fst $1, Jppml.Abs.PCon (fst $1) (snd $1)) }
  | Id { (fst $1, Jppml.Abs.PId (fst $1) (snd $1)) }
  | '_' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.PWild (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1))) }
  | '(' Pat ',' ListPat ')' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.PTup (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '[' ListPat ']' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.PLst (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | IdCap { (fst $1, Jppml.Abs.PObjCon (fst $1) (snd $1)) }
  | '(' Pat ')' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListPat :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.Pat]) }
ListPat
  : {- empty -} { (Jppml.Abs.BNFC'NoPosition, []) }
  | Pat { (fst $1, (:[]) (snd $1)) }
  | Pat ',' ListPat { (fst $1, (:) (snd $1) (snd $3)) }

Pat1 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Pat) }
Pat1
  : IdCap Pat2 { (fst $1, Jppml.Abs.PObj (fst $1) (snd $1) (snd $2)) }
  | Pat2 { (fst $1, (snd $1)) }

Pat :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Pat) }
Pat
  : Pat1 '::' Pat { (fst $1, Jppml.Abs.PCons (fst $1) (snd $1) (snd $3)) }
  | Pat1 { (fst $1, (snd $1)) }

Pat2 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Pat) }
Pat2 : Pat3 { (fst $1, (snd $1)) }

Typ3 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Typ) }
Typ3
  : IdVar { (fst $1, Jppml.Abs.TIdVar (fst $1) (snd $1)) }
  | TypLst Id { (fst $1, Jppml.Abs.TId (fst $1) (snd $1) (snd $2)) }
  | '(' Typ ')' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

TypLst :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.TypLst) }
TypLst
  : {- empty -} { (Jppml.Abs.BNFC'NoPosition, Jppml.Abs.TLEmpty Jppml.Abs.BNFC'NoPosition) }
  | Typ3 { (fst $1, Jppml.Abs.TLOne (fst $1) (snd $1)) }
  | '(' Typ ',' ListTyp ')' { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.TLMany (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListTyp :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.Typ]) }
ListTyp
  : Typ { (fst $1, (:[]) (snd $1)) }
  | Typ ',' ListTyp { (fst $1, (:) (snd $1) (snd $3)) }

Typ1 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Typ) }
Typ1
  : Typ2 '*' ListTTupElem { (fst $1, Jppml.Abs.TTup (fst $1) (snd $1) (snd $3)) }
  | Typ2 { (fst $1, (snd $1)) }

TTupElem :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.TTupElem) }
TTupElem : Typ2 { (fst $1, Jppml.Abs.TTupJust (fst $1) (snd $1)) }

ListTTupElem :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.TTupElem]) }
ListTTupElem
  : TTupElem { (fst $1, (:[]) (snd $1)) }
  | TTupElem '*' ListTTupElem { (fst $1, (:) (snd $1) (snd $3)) }

Typ :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Typ) }
Typ
  : Typ1 '->' Typ { (fst $1, Jppml.Abs.TFn (fst $1) (snd $1) (snd $3)) }
  | Typ1 { (fst $1, (snd $1)) }

Typ2 :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Typ) }
Typ2 : Typ3 { (fst $1, (snd $1)) }

Dec :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.Dec) }
Dec
  : 'let' ListLetBind { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.DLet (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'type' ListTypBind { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.DType (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'exception' ListExnBind { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.DExn (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'open' ListIdCap { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.DOpen (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListIdCap :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.IdCap]) }
ListIdCap
  : IdCap { (fst $1, (:[]) (snd $1)) }
  | IdCap 'and' ListIdCap { (fst $1, (:) (snd $1) (snd $3)) }

ListDec :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.Dec]) }
ListDec
  : {- empty -} { (Jppml.Abs.BNFC'NoPosition, []) }
  | Dec ListDec { (fst $1, (:) (snd $1) (snd $2)) }

LetBind :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.LetBind) }
LetBind
  : Id '=' Exp { (fst $1, Jppml.Abs.LBJust (fst $1) (snd $1) (snd $3)) }
  | '_' '=' Exp { (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1), Jppml.Abs.LBAnon (uncurry Jppml.Abs.BNFC'Position (tokenLineCol $1)) (snd $3)) }

ListLetBind :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.LetBind]) }
ListLetBind
  : LetBind { (fst $1, (:[]) (snd $1)) }
  | LetBind 'and' ListLetBind { (fst $1, (:) (snd $1) (snd $3)) }

TypBind :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.TypBind) }
TypBind
  : TypLst Id '=' ListDTag { (fst $1, Jppml.Abs.TBJust (fst $1) (snd $1) (snd $2) (snd $4)) }
  | TypLst Id '=' '|' ListDTag { (fst $1, Jppml.Abs.tBJust (fst $1) (snd $1) (snd $2) (snd $5)) }

ListTypBind :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.TypBind]) }
ListTypBind
  : TypBind { (fst $1, (:[]) (snd $1)) }
  | TypBind 'and' ListTypBind { (fst $1, (:) (snd $1) (snd $3)) }

DTag :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.DTag) }
DTag
  : IdCap { (fst $1, Jppml.Abs.DTCon (fst $1) (snd $1)) }
  | IdCap 'of' Typ { (fst $1, Jppml.Abs.DTArg (fst $1) (snd $1) (snd $3)) }

ListDTag :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.DTag]) }
ListDTag
  : DTag { (fst $1, (:[]) (snd $1)) }
  | DTag '|' ListDTag { (fst $1, (:) (snd $1) (snd $3)) }

ExnBind :: { (Jppml.Abs.BNFC'Position, Jppml.Abs.ExnBind) }
ExnBind
  : IdCap { (fst $1, Jppml.Abs.EBCon (fst $1) (snd $1)) }
  | IdCap 'of' Typ { (fst $1, Jppml.Abs.EBArg (fst $1) (snd $1) (snd $3)) }

ListExnBind :: { (Jppml.Abs.BNFC'Position, [Jppml.Abs.ExnBind]) }
ListExnBind
  : ExnBind { (fst $1, (:[]) (snd $1)) }
  | ExnBind 'and' ListExnBind { (fst $1, (:) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pListDec :: [Token] -> Err [Jppml.Abs.Dec]
pListDec = fmap snd . pListDec_internal
}

