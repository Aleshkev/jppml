-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelSyntax where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified AbsSyntax

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transId :: AbsSyntax.Id -> Result
transId x = case x of
  AbsSyntax.Id string -> failure x

transIdCap :: AbsSyntax.IdCap -> Result
transIdCap x = case x of
  AbsSyntax.IdCap string -> failure x

transIdVar :: AbsSyntax.IdVar -> Result
transIdVar x = case x of
  AbsSyntax.IdVar string -> failure x

transCon :: Show a => AbsSyntax.Con' a -> Result
transCon x = case x of
  AbsSyntax.CInt _ integer -> failure x
  AbsSyntax.CString _ string -> failure x
  AbsSyntax.CUnit _ -> failure x

transExp :: Show a => AbsSyntax.Exp' a -> Result
transExp x = case x of
  AbsSyntax.ECon _ con -> failure x
  AbsSyntax.EObjCon _ idcap -> failure x
  AbsSyntax.EId _ id -> failure x
  AbsSyntax.ETup _ exp exps -> failure x
  AbsSyntax.ELst _ exps -> failure x
  AbsSyntax.EApp _ exp1 exp2 -> failure x
  AbsSyntax.ENeg _ exp -> failure x
  AbsSyntax.EMul _ exp1 exp2 -> failure x
  AbsSyntax.EDiv _ exp1 exp2 -> failure x
  AbsSyntax.EAdd _ exp1 exp2 -> failure x
  AbsSyntax.ESub _ exp1 exp2 -> failure x
  AbsSyntax.ECons _ exp1 exp2 -> failure x
  AbsSyntax.EAppend _ exp1 exp2 -> failure x
  AbsSyntax.ECat _ exp1 exp2 -> failure x
  AbsSyntax.ERel _ exp1 erelop exp2 -> failure x
  AbsSyntax.EAnd _ exp1 exp2 -> failure x
  AbsSyntax.EOr _ exp1 exp2 -> failure x
  AbsSyntax.EIf _ exp1 exp2 exp3 -> failure x
  AbsSyntax.ELet _ letbinds exp -> failure x
  AbsSyntax.ECase _ exp ecasebinds -> failure x
  AbsSyntax.EFn _ ids exp -> failure x

transERelOp :: Show a => AbsSyntax.ERelOp' a -> Result
transERelOp x = case x of
  AbsSyntax.EREq _ -> failure x
  AbsSyntax.ERNe _ -> failure x
  AbsSyntax.ERLt _ -> failure x
  AbsSyntax.ERLe _ -> failure x
  AbsSyntax.ERGt _ -> failure x
  AbsSyntax.ERGe _ -> failure x

transECaseBind :: Show a => AbsSyntax.ECaseBind' a -> Result
transECaseBind x = case x of
  AbsSyntax.ECBJust _ pat exp -> failure x

transPat :: Show a => AbsSyntax.Pat' a -> Result
transPat x = case x of
  AbsSyntax.PCon _ con -> failure x
  AbsSyntax.PId _ id -> failure x
  AbsSyntax.PWild _ -> failure x
  AbsSyntax.PTup _ pat pats -> failure x
  AbsSyntax.PLst _ pats -> failure x
  AbsSyntax.PObjCon _ idcap -> failure x
  AbsSyntax.PObj _ idcap pat -> failure x
  AbsSyntax.PCons _ pat1 pat2 -> failure x

transTyp :: Show a => AbsSyntax.Typ' a -> Result
transTyp x = case x of
  AbsSyntax.TIdVar _ idvar -> failure x
  AbsSyntax.TId _ typlst id -> failure x
  AbsSyntax.TTup _ typ ttupelems -> failure x
  AbsSyntax.TFn _ typ1 typ2 -> failure x

transTypLst :: Show a => AbsSyntax.TypLst' a -> Result
transTypLst x = case x of
  AbsSyntax.TLEmpty _ -> failure x
  AbsSyntax.TLOne _ typ -> failure x
  AbsSyntax.TLMany _ typ typs -> failure x

transTTupElem :: Show a => AbsSyntax.TTupElem' a -> Result
transTTupElem x = case x of
  AbsSyntax.TTupJust _ typ -> failure x

transDec :: Show a => AbsSyntax.Dec' a -> Result
transDec x = case x of
  AbsSyntax.DLet _ letbinds -> failure x
  AbsSyntax.DType _ typbinds -> failure x
  AbsSyntax.DExn _ exnbinds -> failure x
  AbsSyntax.DOpen _ idcaps -> failure x

transLetBind :: Show a => AbsSyntax.LetBind' a -> Result
transLetBind x = case x of
  AbsSyntax.LBJust _ id exp -> failure x
  AbsSyntax.LBAnon _ exp -> failure x

transTypBind :: Show a => AbsSyntax.TypBind' a -> Result
transTypBind x = case x of
  AbsSyntax.TBJust _ typlst id dtags -> failure x

transDTag :: Show a => AbsSyntax.DTag' a -> Result
transDTag x = case x of
  AbsSyntax.DTCon _ idcap -> failure x
  AbsSyntax.DTArg _ idcap typ -> failure x

transExnBind :: Show a => AbsSyntax.ExnBind' a -> Result
transExnBind x = case x of
  AbsSyntax.EBCon _ idcap -> failure x
  AbsSyntax.EBArg _ idcap typ -> failure x
